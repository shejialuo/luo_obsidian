---
tags:
  - 内存与缓存
  - 技术
---

# 物理缓存

## 物理缓存的基本操作

物理缓存完全采用物理地址作为索引。由于物理地址具有的唯一性，其能够避免歧义和别名问题。如下图所示，首先虚拟地址通过MMU转化为物理地址，然后根据物理地址判断缓存是否命中。

![物理缓存结构](https://s2.loli.net/2023/08/18/YnqESIGakT18t9m.png)

### I/O与总线监听技术

物理缓存基于总线监听技术来保证I/O操作的缓存一致性。如下图所示，总线连接了CPU/MMU/cache，内存以及I/O设备。使得每个设备都能收到其他设备的广播信息。如下图所示，当CPU需要读内存时，其会把物理地址的信息通过总线发送给内存，然后内存会把值发送给CPU。

![System bus](https://s2.loli.net/2023/08/18/i9hl3CYW1ndFfVH.png)

总线中的数据传递是基于事务的思想实现的，通过一个或者多个总线事务进行传输。每一个总线事务只能够发送一定大小的数据，例如当需要从从磁盘里面读取数据时，会划分为多个总线事务，每个事务都会包含内存地址及数据。所有的设备都可以观察总线上的事务，当物理缓存没有使用总线时，其会监听总线上所有的总线事务(*snooping*)。

物理缓存会检查每个总线事务的地址，去判断给物理地址是否命中缓存，如果没有命中缓存，我们什么也不需要处理。然而当命中了缓存后，我们就需要思考如何进行处理呢。我们首先考虑*write-through*策略，当I/O设备需要从这个地址读取内容时，我们不需要采取任何的内容，因为*write-through*策略保证了缓存和内存的一致性。然而，当I/O设备需要写入内容到该地址时，必须要把对应的物理缓存的cache line的valid位置为0，从而让下次读取时产生cache miss，让CPU从内存中读取数据，保证缓存与内存的一致性。当然，有些实现直接修改cache line的block值。

对于*write-back*策略，当I/O设备需要从这个地址读取内容时，如果dirty位为0，I/O设备可以直接从内存中读，如果dirty为1，I/O设备直接从cache读取数据，对于I/O设备中这个过程是透明的，I/O设备并不知道它是从内存读还是缓存读的。当I/O设备需要写入内容到该地址时，如果其dirty位为0，缓存可以直接将其valid位置为0。如果正好写入的大小等于cache line，那么我们就可以直接替代cache line的值，然而很有可能写入的大小小于cache line，就需要硬件提供局部写入的机制，因为不能丢失原先已经写入的缓存的信息。
